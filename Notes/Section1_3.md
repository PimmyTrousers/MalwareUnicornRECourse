## Section 1.3 Fundamentals:

### x86 assembly language
The C programming language is a high level language interpreterd by the compiler that converts code into machine instructions called assembly language. By using a dissasembler tool we can get the assembly language of a compiled C program.

The intel 8086 and 8088 were the first CPUs to hae an instruction set that in now ommonly referred to as x86.

The x86 architecture is **little_endian**, meaning that multi-byte values are written least sginificantly byte first

**how we see it:**
| a0 | a1 | a2 | a3 |

**Stored in Little Endian:**
| a3 | a2 | a1 | a0 |

### Opcodes and Instructions
Each instruction represents opcodes (hex code) that tells the machine what to do next.

Three Categories of instructions:
  - Data Movement/Access
  - Arithmetic / Logic
  - Control-Flow

Common Instructions
  - **mov, lea** (data movement, data access)
  - **add, sub** (arithmetic)
  - **or, and, xor** (Logic)
  - **shr, shl** (Logic)
  - **ror, rol** (Logic)
  - **jmp, jne, jnz, jnb** (Control Flow)
  - **push, pop, calll, leave, enter, ret** (Control Flow)

Exmaple below is moving value at 0xaaaaaaaa into ecx
  mov ecx,[0xaaaaaaaa];           8B 0D AA AA AA AA

### Registers

#### General Purpose Registers:
  - EAX --> Accumulator Register
  - EBX --> Base Register
  - ECX --> Counter Register
  - EDX --> Data Register
  - ESI --> Source Index
  - EDI --> Destination Index
  - EBP --> Base Pointer
  - ESP --> Stack Pointer

#### Segment Registers:
  - SS --> Stack Segment, Pointer to the stack
  - CS --> Code Segment, Pointer to the code
  - DS --> Data Segment, Pointer to the data
  - ES --> Extra Segment Pointer to the extra data
  - FS --> F Segment, Pointer to more extra data
  - GS --> G Segment, Pointer to still more etra data

#### EFLAGS Register
  - **CF** Carry Flag
    - Set if the last arithmetic operation carried (addition) or borrowed (subtraction) a bit beyond the size of the register. This is then checked when the operation is followed with an add-with-carry or subtract-with-borrow to deal with values too large for just one register to contain
  - **PF** Parity Flag
    - Set if the number of set bits in the least significant byte is a multiple of 2
  - **AF** Adjust Flag
    - Carry of Binary Code Decimal (BCD) numbers arithmetic operations
  - **ZF** Zero Flag
    - Set if the result of an operation is Zero (0)
  - **SF** Sign Flag
    - Set if the result of an operation is negative
  - **TF** Trap Flag
    - Set if step by step debugging
  - **IF** Interrupt Flag
    - Set if interrupts are enabled
  - **DF** Direction Flag
    - Stream direction. If set, string operations will decrement their pointer rather than incrementing it, reading memory backwards
  - **OF** Overflow Flag
    - Set if signed arithmetic operations result in a value too large for the register to contain
  - **IOPL** I/O Privilege Level Field (2 bits)
    - I/O Privilege Level of the current process
  - **NT** Nested Task Flag
    - Controls chaining of interrupts. Set if the current process is linked to the next process
  - **RF** Resume Flag
    - Response to debug exceptions
  - **VM** Virtual Interrupt Flag
    - Virtual image of IF
  - **VIP** Virtual Interrupt Pending Flag
    - Set if an interrupt is Pending
  - **ID** Identification Flag
    - Support for CPUID instruction if can be set

#### Instruction Pointer
The **EIP** register contains the address of th enext instructin to be executed.

### Hello World
See HelloWorld image

### Calling a Function
#### Arguments on the Stack
See StackFrame image

#### Local Variables on the Stack
See FunctionCall2 image
